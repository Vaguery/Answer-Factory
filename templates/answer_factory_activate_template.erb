#encoding: utf-8
require 'answer-factory'
include Nudge
include AnswerFactory

####
####
#### EDIT THESE SETTINGS TO SUIT YOUR PROJECT:
####
####


#### CouchDB access:
configatron.factory.couchdb.server =          'http://127.0.0.1:5984'

#### Factory settings:
configatron.factory.name =                    'sample_factory'

#### Workstation definitions:
configatron.project.workstations.path =       '/lib/factory/workstations/*'

#### Nudge language extensions:
configatron.project.nudge.instructions.path = '/lib/nudge/instructions/*'
configatron.project.nudge.types.path =        '/lib/nudge/types/*'


#### normally these should be in /lib/factory/workstations/**

class GenerationStation < Workstation
  attr_reader :random_program_maker
  
  def initialize(name, options = {})
    super
    @random_program_maker = Machines::BuildRandom.new(
      how_many:10,
      target_size_in_points:20, 
      reference_names:["x1", "x2"])
  end
  
  def build!
    @answers = process_with @random_program_maker
    @answers.each {|a| a.location = :maker}
    puts
    puts "MAKER BUILD: made #{@answers.length}"
  end
  
  def ship!
    ship_to(:polisher) {|answer| true}
    puts "MAKER SHIP -> POLISHER"
  end
end


class VariationStation < Workstation
  attr_reader :my_length_evaluator
  
  def initialize(name, options = {})
    super
    @mutator = Machines::MutateFootnotesUniform.new
    @score_1 = Machines::EvaluateSimpleScore.new(
      :name => :number_of_footnotes,
      scorer:Proc.new {|a| a.blueprint.scan(/^Â«/).length})
  end
  
  def receive!
    gather_mine
    puts "POLISHER RECEIVE: got #{@answers.length}"
  end
  
  def build!
    @mutants = process_with @mutator
    @mutants.each {|a| @answers << a}
    @answers = process_with @score_1
    puts "POLISHER BUILD: has #{@answers.length}"
  end
  
  def ship!
    ship_to(:picker) {|answer| rand < 0.25}
    puts "POLISHER SHIP: kept #{@answers.find_all {|a| a.location == :polisher}.length}"
  end
  
  def scrap!
    scrap_if("contains 'oo'") {|a| a.blueprint.include? 'oo'}
    puts "POLISHER SCRAP: kept #{@answers.find_all {|a| a.location == :polisher}.length}"
  end
end


class ScreeningStation < Workstation
  attr_reader :letters
  
  def initialize(name, options = {})
    super
    @letters = Machines::EvaluateSimpleScore.new(
      :name => :letters,
      scorer:Proc.new {|a| a.blueprint.length})
    @so_far_so_good = Machines::SelectNondominated.new
  end
  
  def receive!
    gather_mine
    puts "PICKER RECEIVE: got #{@answers.length}"
  end
  
  def build!
    @answers = process_with @letters
    @best = process_with @so_far_so_good
    puts "----------"
    puts "PICKER HAS THESE: #{@answers.length}"
    @answers.each {|a| puts a.scores}
    puts "----------"
    puts "PICKER NONDOMINATED SET: #{@best.length}"
    @best.each {|a| puts "#{a.couch_id}: #{a.scores}"}
  end
  
  def scrap!
    scrap_if("dominated") {|a| !@best.include?(a)}
    puts "PICKER SCRAP: kept #{@answers.find_all {|a| a.location == :picker}.length}"
  end
end


##### this will soon be an attribute of the Factory, and saved as persistent config data
# but it's the components of your Factory instance, each of which will be sent a #cycle! message,
# in this order, by the launch code below
workstations =[
  GenerationStation.new(:maker),
  VariationStation.new(:polisher),
  ScreeningStation.new(:picker)]


####
####
#### DON'T EDIT BEYOND THIS POINT
####
####

# extend Nudge
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.instructions.path) {|file| require file}
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.types.path) {|file| require file}

# confirm database access
raise "CouchDB not available at #{configatron.factory.couchdb.server}" unless
  Factory.couch_available?()

# extend Workstation
Dir.glob(File.dirname(__FILE__) + configatron.project.workstations.path) {|file| require file}


### these should get tucked away elsewhere:

project = Factory.new()

# reset database
db = CouchRest.database!("#{configatron.factory.couchdb.server}/#{configatron.factory.name}")
db.delete!
db.create!


# create required view document(s) [should be part of generating each workstation]
db.batch_save_doc({'_id' => "_design/maker", views: { current: { map: "function(doc) {
  if(doc.location == 'maker') {
    emit(doc._id, doc);
  }
}"}}})

db.batch_save_doc({'_id' => "_design/polisher", views: { current: { map: "function(doc) {
  if(doc.location == 'polisher') {
    emit(doc._id, doc);
  }
}"}}})

db.batch_save_doc({'_id' => "_design/picker", views: { current: { map: "function(doc) {
  if(doc.location == 'picker') {
    emit(doc._id, doc);
  }
}"}}})


# final workcycle behavior
100.times do
  workstations.each do |ws|
    ws.cycle
  end
end