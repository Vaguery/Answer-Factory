#encoding: utf-8
require 'answer-factory'
include Nudge
include AnswerFactory

####
####
#### EDIT THESE SETTINGS TO SUIT YOUR PROJECT:
####
####


#### CouchDB access:
configatron.factory.couchdb.server =          'http://127.0.0.1:5984'

#### Factory settings:
configatron.factory.name =                    'polynomial2'
configatron.factory.training_datasource =     "http://127.0.0.1:5984/polynomial2_training"

#### Workstation definitions:
configatron.project.workstations.path =       '/lib/factory/workstations/*'

#### Nudge language extensions:
configatron.project.nudge.instructions.path = '/lib/nudge/instructions/*'
configatron.project.nudge.types.path =        '/lib/nudge/types/*'


#### normally these should be in /lib/factory/workstations/**

class GenerationStation < Workstation

  def initialize(name, options = {})
    super
    @random_program_maker = Machines::BuildRandom.new(
      how_many:10,
      target_size_in_points:80, 
      reference_names:["x1", "x2", "x3", "x4"],
      instruction_names:[:int_add, :int_subtract, :int_multiply,
        :int_divide, :int_modulo, :int_max, :int_min],
      type_names:[:int])
  end
  
  def build!
    @answers = process_with @random_program_maker
    @answers.each {|a| a.location = :maker}
  end
  
  def ship!
    ship_to(:scoring_station) {true}
  end
end


class ScoringStation < Workstation

  def initialize(name, options = {})
    super
    @scorer = Machines::EvaluateWithTestCases.new(
      :name => :polynomial_fit,
      training_data_csv: "poly1.csv")      
    @scorer.install_training_data_from_csv
    @scorer.build_sensor("y1") {|interpreter| interpreter.peek_value(:int) || 2000000}
  end
  
  def receive!
    gather_mine
  end
  
  def build!
    @answers = process_with @scorer
  end
  
  def ship!
    ship_to(:picker) {true}
  end
end


class ScreeningStation < Workstation

  def initialize(name, options = {})
    super
    @letters = Machines::EvaluateSimpleScore.new(
      :name => :letters,
      scorer:Proc.new {|a| a.blueprint.length})
    @so_far_so_good = Machines::SelectNondominated.new
  end
  
  def receive!
    gather_mine
  end
  
  def build!
    @answers = process_with @letters
    @best = process_with @so_far_so_good
    puts "----------"
    puts "PICKER HAS THESE: #{@answers.length}"
    @answers.each {|a| puts a.scores}
    puts "----------"
    puts "PICKER NONDOMINATED SET: #{@best.length}"
    @best.each {|a| puts "#{a.couch_id}: #{a.scores}"}
  end
  
  def scrap!
    scrap_if("dominated") {|a| !@best.include?(a)}
  end
end


##### this will soon be an attribute of the Factory, and saved as persistent config data
# but it's the components of your Factory instance, each of which will be sent a #cycle! message,
# in this order, by the launch code below
# workstations =[
#   GenerationStation.new(:maker),
#   ScoringStation.new(:scoring_station),
#   ScreeningStation.new(:picker)]

####
####
#### DON'T EDIT BEYOND THIS POINT
####
####

# extend Nudge
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.instructions.path) {|file| require file}
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.types.path) {|file| require file}

# confirm database access
raise "CouchDB not available at #{configatron.factory.couchdb.server}" unless
  Factory.couch_available?()

# extend Workstation
Dir.glob(File.dirname(__FILE__) + configatron.project.workstations.path) {|file| require file}


### these should get tucked away elsewhere:

project = Factory.new()

# reset database
db = CouchRest.database!("#{configatron.factory.couchdb.server}/#{configatron.factory.name}")
db.delete!
db.create!

db_train = CouchRest.database!("#{configatron.factory.training_datasource}")
db_train.delete!
db_train.create!


    workstations =[
      GenerationStation.new(:maker),
      ScoringStation.new(:scoring_station),
      ScreeningStation.new(:picker)]



# create required view document(s)
workstations.each {|ws| ws.couchdb_create_view}


# final workcycle behavior
1000.times do
  workstations.each do |ws|
    ws.cycle
  end
end
