require 'answer-factory'
include Nudge
include AnswerFactory

####
####
#### EDIT THESE SETTINGS TO SUIT YOUR PROJECT:
####
####


#### CouchDB access:
configatron.factory.couchdb.server =          'http://127.0.0.1:5984'

#### Factory settings:
configatron.factory.name =                    'sample_factory'

#### Workstation definitions:
configatron.project.workstations.path =       '/lib/factory/workstations/*'

#### Nudge language extensions:
configatron.project.nudge.instructions.path = '/lib/nudge/instructions/*'
configatron.project.nudge.types.path =        '/lib/nudge/types/*'



#### normally these should be in /lib/factory/workstations/**

class GeneratorStation < Workstation
  attr_reader :random_program_maker
  
  def initialize(name, options = {})
    super
    @random_program_maker = Machines::BuildRandom.new(
      how_many:10,
      target_size_in_points:7, 
      reference_names:["x1", "x2"])
  end
  
  def build!
    @answers = process_with @random_program_maker
    puts "#{self.name}: built and now have: #{@answers.length}"
  end
  
  def ship!
    ship_to(:breeder) {|answer| true} 
    puts "#{self.name}: shipping to #{@answers.collect {|a| a.tags.to_a}.inspect}"
  end
end


class EvolverStation < Workstation
  attr_reader :my_value_adjuster
  attr_reader :my_length_evaluator
  
  def initialize(name, options = {})
    super
    @my_value_adjuster = Machines::MutateFootnotesUniform.new(
      target_size_in_points:7)
    @my_length_evaluator = Machines::EvaluateSimpleScore.new(
      :name => :blueprint_length,
      scorer:Proc.new {|a| a.blueprint.length})
  end
  
  def receive!
    gather_mine
    puts "#{self.name}: received and now have: #{@answers.length}"
  end
  
  def build!
    process_with @my_value_adjuster
    process_with @my_length_evaluator
    puts "#{self.name}: built and now have: #{@answers.length}"
  end
  
  def scrap!
    puts "\n\n#{self.name}: tags begin as #{@answers.collect {|a| a.tags.to_a}}"
    @best_score = (@answers.collect {|a| a.scores[:blueprint_length]}).min
    scrap_if("too_long") {|a| (a.scores[:blueprint_length] > @best_score)}
    puts "#{self.name}: tags ended as #{@answers.collect {|a| a.tags.to_a}}"
    puts "#{self.name}: scores ended as #{@answers.collect {|a| a.scores.values}}\n\n"
  end
end


####
####
#### DON'T EDIT BEYOND THIS POINT
####
####

# extend Nudge
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.instructions.path) {|file| require file}
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.types.path) {|file| require file}

# confirm database access
raise "CouchDB not available at #{configatron.factory.couchdb.server}" unless
  Factory.couch_available?()

# extend Workstation
Dir.glob(File.dirname(__FILE__) + configatron.project.workstations.path) {|file| require file}

project = Factory.new()
workstations = [GeneratorStation.new(:maker), EvolverStation.new(:breeder)]

# write view document(s)
db = CouchRest.database!("#{configatron.factory.couchdb.server}/#{configatron.factory.name}")
db.delete!
db.create!

db.save_doc({'_id' => "_design/breeder", views: { current: { map: "function(doc) { if(doc.tags.length > 0) { for(var idx in doc.tags) { if(doc.tags[idx] == 'breeder') {emit(doc._id, doc)   }}}}"}}})

2.times do
  workstations.each do |ws|
    ws.cycle
  end
end