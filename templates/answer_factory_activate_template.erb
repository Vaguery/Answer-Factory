require 'answer-factory'
include Nudge
include AnswerFactory

####
####
#### EDIT THESE SETTINGS TO SUIT YOUR PROJECT:
####
####


#### CouchDB access:
configatron.factory.couchdb.server =          'http://127.0.0.1:5984'

#### Factory settings:
configatron.factory.name =                    'sample_factory'

#### Workstation definitions:
configatron.project.workstations.path =       '/lib/factory/workstations/*'

#### Nudge language extensions:
configatron.project.nudge.instructions.path = '/lib/nudge/instructions/*'
configatron.project.nudge.types.path =        '/lib/nudge/types/*'


#### normally these should be in /lib/factory/workstations/**

class GeneratorStation < Workstation
  attr_reader :random_program_maker
  
  def initialize(name, options = {})
    super
    @random_program_maker = Machines::BuildRandom.new(
      how_many:10,
      target_size_in_points:7, 
      reference_names:["x1", "x2"])
  end
  
  def receive!
    gather_mine
    puts "#{self.name}: received and now have: #{@answers.length}"
    puts "\n\n#{self.name}: locations are #{@answers.collect {|a| a.location}}"
    
  end
  
  def build!
    @answers = process_with @random_program_maker
    @answers.each {|a| a.location = 'maker'}
    puts "#{self.name}: built and now have: #{@answers.length}"
  end
  
  def ship!
    ship_to(:breeder) {|answer| true} 
    puts "#{self.name}: shipping to #{@answers.collect {|a| a.location}.inspect}"
  end
end


class EvaluatorStation1 < Workstation
  attr_reader :my_length_evaluator
  
  def initialize(name, options = {})
    super
    @my_length_evaluator = Machines::EvaluateSimpleScore.new(
      :name => :blueprint_length,
      scorer:Proc.new {|a| a.blueprint.length})
  end
  
  def receive!
    gather_mine
    puts "#{self.name}: received and now have: #{@answers.length}"
    puts "\n\n#{self.name}: locations are #{@answers.collect {|a| a.location}}"
  end
  
  def build!
    @answers = process_with @my_length_evaluator
    puts "#{self.name} BUILD : built and now have: #{@answers.length}"
  end
  
  def ship!
    ship_to(:marker) {|answer| rand < 0.5} 
    puts "#{self.name} SHIP: shipping to #{@answers.collect {|a| a.location}.inspect}"
  end
  
  def scrap!
    puts "\n\n#{self.name} SCRAP: tags begin as #{(@answers.collect {|a| a.location})}"
    @best_score = (@answers.collect {|a| a.scores[:blueprint_length]}).min
    scrap_if("too_long") {|a| (a.scores[:blueprint_length] > @best_score)}
    puts "#{self.name} SCRAP: tags ended as #{(@answers.collect {|a| a.location})}"
    puts "#{self.name} SCRAP: scores ended as #{(@answers.collect {|a| a.scores.values})}\n\n"
  end
end


class EvaluatorStation2 < Workstation
  attr_reader :my_length_evaluator
  
  def initialize(name, options = {})
    super
    @my_length_evaluator = Machines::EvaluateSimpleScore.new(
      :name => :points,
      scorer:Proc.new {|a| a.points})
  end
  
  def receive!
    gather_mine
    puts "#{self.name}: received and now have: #{@answers.length}"
    puts "\n\n#{self.name}: locations are #{@answers.collect {|a| a.location}}"
  end
  
  def build!
    @answers = process_with @my_length_evaluator
    puts "#{self.name} BUILD : built and now have: #{@answers.length}"
  end
  
  def scrap!
    puts "\n\n#{self.name} SCRAP: tags begin as #{(@answers.collect {|a| a.location})}"
    @best_score = (@answers.collect {|a| a.scores[:points]}).min
    scrap_if("too_long") {|a| (a.scores[:points] > @best_score)}
    puts "#{self.name} SCRAP: tags ended as #{(@answers.collect {|a| a.location})}"
    puts "#{self.name} SCRAP: scores ended as #{(@answers.collect {|a| a.scores.values})}\n\n"
  end
end



####
####
#### DON'T EDIT BEYOND THIS POINT
####
####

# extend Nudge
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.instructions.path) {|file| require file}
Dir.glob(File.dirname(__FILE__) + configatron.project.nudge.types.path) {|file| require file}

# confirm database access
raise "CouchDB not available at #{configatron.factory.couchdb.server}" unless
  Factory.couch_available?()

# extend Workstation
Dir.glob(File.dirname(__FILE__) + configatron.project.workstations.path) {|file| require file}


### these should get tucked away elsewhere:

project = Factory.new()
workstations =[
  GeneratorStation.new(:maker),
  EvaluatorStation1.new(:breeder),
  EvaluatorStation2.new(:marker)]

# reset database
db = CouchRest.database!("#{configatron.factory.couchdb.server}/#{configatron.factory.name}")
db.delete!
db.create!


# create required view document(s) [should be part of generating each workstation]
db.batch_save_doc({'_id' => "_design/marker", views: { current: { map: "function(doc) {
  if(doc.location == 'marker') {
    emit(doc._id, doc);
  }
}"}}})

db.batch_save_doc({'_id' => "_design/breeder", views: { current: { map: "function(doc) {
  if(doc.location == 'breeder') {
    emit(doc._id, doc);
  }
}"}}})

db.batch_save_doc({'_id' => "_design/maker", views: { current: { map: "function(doc) {
  if(doc.location == 'maker') {
    emit(doc._id, doc);
  }
}"}}})


# final workcycle behavior
10.times do
  workstations.each do |ws|
    ws.cycle
  end
end