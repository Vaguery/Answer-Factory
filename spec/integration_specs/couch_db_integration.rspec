require File.join(File.dirname(__FILE__), "./../spec_helper")

# CouchDB MUST BE RUNNING BEFORE YOU RUN THESE

class ShipperStation < Workstation
  def receive!
    gather_mine
  end
  
  def ship!
    ship_to(:that_place) {|answer| true} 
  end
end


describe "CouchDB stuff" do
  before(:each) do
    
    configatron.factory.couchdb.server = "http://127.0.0.1:5984"
    configatron.factory.couchdb.name = "integration_test_db"
    break("CouchDB is offline") unless Factory.couch_available?
    @db_uri = "#{configatron.factory.couchdb.server}/#{configatron.factory.couchdb.name}"
  end
  
  after(:all) do
    CouchRest.database!(@db_uri).delete!
    CouchRest.database!("#{@db_uri}_training").delete!
  end
  
  
  describe "Factory CouchDB interaction" do
    it "should actually return 'true' if the db is reachable" do
      Factory.couch_available?.should be true
    end
    
    it "should actually return 'false' if the db is unavailable" do
      FakeWeb.allow_net_connect = false
      Factory.couch_available?.should be false
      FakeWeb.allow_net_connect = true
    end
  end
  
  
  describe "Machine CouchDB interaction" do
    before(:each) do
      the_database_name = "#{@db_uri}_training"
      @db = CouchRest.database!(the_database_name)
      @db.save_doc({"inputs" => {"x1" => 7}, "outputs" => {"y1" => 12}})
      @db.save_doc(
        {'_id' => "_design/tester",
        views: { test_cases: { map: 
          "function(doc) { emit(doc._id, doc); }"}}})
    end
    
    it "should use load_training_data! to access the right view" do
      configatron.temp do
        configatron.factory.training_datasource = "http://127.0.0.1:5984/integration_test_db_training"
        @my_machine = Machines::EvaluateWithTestCases.new(name: :tester)
        @my_machine.load_training_data!
        @my_machine.test_cases[0].inputs["x1"].should == 7
      end
    end
  end
  
  describe "Batch reading and writing" do
    describe "updating a Batch" do
      before(:each) do
        @batch = Batch.[](Answer.new("do a"), Answer.new("do b"))
      end

      describe "Batch#bulk_save!" do
        it "should capture the couch_id values in the Answers themselves" do
          old_ids = @batch.collect {|a| a.couch_id}
          @batch.bulk_save!(@db_uri)
          new_ids = @batch.collect {|a| a.couch_id}
          old_ids.should_not == new_ids
        end
        
        it "should capture the couch_rev values in the Answers themselves" do
          @batch.bulk_save!(@db_uri)
          new_revs = @batch.collect {|a| a.couch_rev}
          new_revs.each {|r| r.should_not == ""}
        end
      end
      
      
      it "should be possible to set the couchdb_id and have that be actually used" do
        @batch[0].couch_id = "001"
        @batch[1].couch_id = "002"
        ids = @batch.bulk_save!(@db_uri).collect {|r| r["id"]}
        ids.should == ["001", "002"]
      end
      
      it "should be possible to overwrite a document with new info" do
        @batch.bulk_save!(@db_uri)
        
        db = CouchRest.database!(@db_uri)
        as_saved = db.get(@batch[0].couch_id)["_rev"]
        @batch[0].scores[:wellness] = 0
        @batch.bulk_save!(@db_uri)
        and_now = db.get(@batch[0].couch_id)["_rev"]
        as_saved[0].should == "1"
        and_now[0].should == "2"
      end
      
    end
  end
  
  
  describe "Workstations passing Batches around" do
    
    describe "couchdb_create_view" do
      before(:each) do
        @ws_viewer = Workstation.new(:view_maker)
      end
      
      it "should save a view doc" do
        response = @ws_viewer.couchdb_create_view
        # "ok"=>true, "id"=>"_design/view_maker", "rev"=>"1-a813357133c1538c86168966b36f97bd"}
        response["ok"].should == true
        response["id"].should == "_design/view_maker"
      end
    end
    
    describe "gathering" do
      before(:each) do
        @ws1 = ShipperStation.new(:this_place)
        @batch = Batch.[](
          Answer.new("do a", location: :this_place), 
          Answer.new("do b", location: :this_place),
          Answer.new("do c", location: :elsewhere))
        CouchRest.database!(@db_uri).
          batch_save_doc({'_id' => "_design/this_place",
            views: { current: { map: 
              "function(doc) { if(doc.location == 'this_place') { emit(doc._id, doc); } }"}}})
        @batch.bulk_save!(@db_uri)
      end
      
      it "should gather the right ones" do
        @ws1.receive!
        @ws1.answers.length.should == 2
        @ws1.answers.collect {|a| a.blueprint}.sort.should == ["do a", "do b"]
      end
      
      it "should capture the :_id and :_rev fields of the records" do
        @ws1.receive!
        @ws1.answers.each {|a| a.couch_id.should_not == ""}
        @ws1.answers.each {|a| a.couch_rev.should_not == ""}
      end
    end
    
    
    describe "shipping" do
      before(:each) do
        @ws1 = ShipperStation.new(:this_place)
        @batch = Batch.[](
          Answer.new("do a", location: :this_place), 
          Answer.new("do b", location: :this_place),
          Answer.new("do c", location: :elsewhere))
        CouchRest.database!(@db_uri).
          batch_save_doc({'_id' => "_design/this_place",
            views: { current: { map: 
              "function(doc) { if(doc.location == 'this_place') { emit(doc._id, doc); } }"}}})
        @batch.bulk_save!(@db_uri)
      end
      
      it "should not be able to re-gather Answers it has shipped away" do
        @ws1.cycle # load, ship, and save
        @ws1.receive!
        @ws1.answers.length.should == 0
      end
    end
    
  end
  
  
end